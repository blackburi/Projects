# DB의 동시성 제어

- DB의 동시성이란? 여러 사용자가 동시에 데이터에 접근하더라도 서로의 작업에 영향을 주지 않고 데이터의 정합성을 보장하는 기능

# DB의 동시성 문제 발생 원인

- 여러 서버가 db서버에 동시 접근할 때
- 한 서버에서 여러 스레드로 db 서버에 동시 접근할 때
- 여러 트랜잭션이 동시에 도착할 때

## 해결 방안
    
#### 비관적 락(Perssimistic Lock)
- 정의
    - 데이터에 대한 접근을 미리 막아, 충돌 가능성을 사전에 차단하는 방식
    - 락이 걸린 동안 다른 트랜잭션이 해당 데이터를 수정할 수 없게 만든다
- 특징
    - 다른 스레드가 점유하고 있으면 락 때문에 사용 불가 -> 다른 스레드가 다시 접근 시도
    - JPA에서 for update가 붙은 쿼리가 나감
    - 충돌이 빈번하거나 빈번하게 일어날꺼라 생각하면 비관적 락 사용

    - 장점 : 락을 통해 업데이트를 제어하여 데이터의 정합성을 보장
    - 단점 : 별도의 락을 잡기 때문에 성능이 감소될 수 있음

- 사용법
    - Repository -> `Lock(LockModeType.PESSIMISTIC_WRITE)`

#### 낙관적 락(Optimistic Lock)
- 정의
    - 데이터 수정 시점에서 충돌을 감지하는 방식
    - 별도의 락을 걸지 않으며, 충돌이 발생할 경우 트랜잭션을 롤백하고 개발자가 다시 시도하는 방식

- 특징
    - 버전에 수정사항이 생기면 다시 읽고 수정을 진행해야함(version은 jpa에서 알아서 관리해준다고 함)
    - 낙관적 락은 재시도를 해줘야 함(Thread.sleep()을 통해서 term을 준다)
    - 빈번하게 일어나지 않을 것이라고 생각하면 낙관적 락 사용

    - 장점 : 별도의 락을 잡지 않아 성능상 이점이 존재
    - 단점 : 실패 시 재시도 로직을 개발자가 직접 작성해야 함

- 사용법
    - Entity -> `@Version private Long version` -> field에 추가
    - Repository -> `Lock(LockModeType.OPTIMISTIC)`

## 후기

- 저번 프로젝트 진행 중에 one_days라는 테이블에 userId와 해당 날짜로 유니크 제약 조건을 줬는데도 여러 트랜잭션이 한 번에 접근하는 바람에 같은 날짜임에도 여러 개의 one_days 레코드가 생성되는 참사가 발생했었다. 이 때 뭣도 모르고 비관적 락으로 해결을 했었는데 자세히 설명을 들어서 좋았다.